@startuml class-diagram
title Key Classes and Data Structures

class PeerManager {
    - config: ConfigManager
    - logger: LogsManager
    - dht: DHTPeer
    - quic: QUICPeer
    - dbManager: SQLiteManager
    - relayManager: RelayManager
    - topics: map[string]*TopicState
    --
    + Start()
    + Stop()
    + SubscribeToTopic(topic)
    + HandleConnectionFailure(addr)
    + VerifyPeerReachabilityOnFailure(nodeID, topic)
    - periodicPeerReachabilityCheck()
    - verifyAllPeerReachability()
    - verifyPeerReachability(metadata): bool
}

class QUICPeer {
    - config: ConfigManager
    - logger: LogsManager
    - connections: map[string]*quic.Conn
    - onConnectionFailure: func(string)
    - onRelayDiscovered: func(*PeerMetadata)
    --
    + ConnectToPeer(addr): Connection
    + Ping(addr): error
    + QueryRelayForSession(relayAddr, clientID, queryID): bool
    + SendMessage(addr, message)
    + SetConnectionFailureCallback(callback)
    + RequestPeerMetadata(addr, topic)
    - handleRelaySessionQuery(msg): Message
}

class DHTPeer {
    - server: *dht.Server
    - nodeID: krpc.ID
    - onPeerDiscovered: func(addr, topic)
    --
    + Start()
    + Stop()
    + AnnounceForTopic(topic, port)
    + FindPeersForTopic(topic): []NodeAddr
    + SetPeerDiscoveredCallback(callback)
    + NodeID(): string
}

class RelayManager {
    - selector: RelaySelector
    - currentRelay: RelayCandidate
    - sessionID: string
    --
    + Start()
    + Stop()
    + AddRelayCandidate(metadata)
    + SelectAndConnectRelay()
    + ConnectToRelay(relay)
    + DisconnectRelay()
    - sendKeepalives()
    - handleRelayConnectionLoss()
}

class RelaySelector {
    - candidates: map[string]*RelayCandidate
    - bestRelay: RelayCandidate
    --
    + AddCandidate(metadata)
    + RemoveCandidate(nodeID)
    + MeasureLatency(candidate): Duration
    + MeasureAllCandidates()
    + SelectBestRelay(): RelayCandidate
    + ShouldSwitchRelay(current, new): bool
    + GetBestRelay(): RelayCandidate
}

class RelayPeer {
    - sessions: map[string]*RelaySession
    - registeredClients: map[string]*ClientInfo
    --
    + HandleRelayRegister(msg, conn): Message
    + HandleRelaySessionQuery(msg): Message
    + HandleRelayDisconnect(msg)
    - monitorSession(session)
    - terminateSession(sessionID, reason)
}

class PeerMetadataDB {
    - db: *sql.DB
    --
    + StorePeerMetadata(metadata)
    + GetPeerMetadata(nodeID, topic): Metadata
    + GetPeersByTopic(topic): []Metadata
    + DeletePeerMetadata(nodeID, topic)
    + UpdateLastSeen(nodeID, topic, source)
}

class RelayDB {
    - db: *sql.DB
    --
    + CreateSession(sessionID, clientID, relayID, type, keepalive)
    + HasActiveSession(clientNodeID): (bool, sessionID)
    + UpdateSessionKeepalive(sessionID)
    + CloseSession(sessionID)
    + RecordTraffic(sessionID, peerID, relayID, type, ingress, egress)
    + GetSessionStats(sessionID): map
}

class PeerMetadata {
    + NodeID: string
    + Topic: string
    + NetworkInfo: NetworkInfo
    + Capabilities: []Capability
    + LastSeen: time.Time
    + Source: string
}

class NetworkInfo {
    + PublicIP: string
    + PublicPort: int
    + PrivateIP: string
    + PrivatePort: int
    + NodeType: string
    + NATType: string
    + IsRelay: bool
    + RelayEndpoint: string
    + RelayPricing: float64
    + UsingRelay: bool
    + ConnectedRelay: string
    + RelaySessionID: string
    + Protocols: []Protocol
}

class RelayCandidate {
    + NodeID: string
    + Endpoint: string
    + Latency: Duration
    + ReputationScore: float64
    + PricingPerGB: float64
    + Capacity: int
    + LastSeen: time.Time
    + Metadata: *PeerMetadata
}

class RelaySession {
    + SessionID: string
    + ClientNodeID: string
    + RelayNodeID: string
    + ClientConn: *quic.Conn
    + StartTime: time.Time
    + LastKeepalive: time.Time
    + KeepaliveInterval: Duration
    + IngressBytes: int64
    + EgressBytes: int64
}

' Relationships
PeerManager *-- DHTPeer
PeerManager *-- QUICPeer
PeerManager *-- RelayManager
PeerManager --> PeerMetadataDB

QUICPeer ..> RelayPeer : delegates relay\nmessages

RelayManager *-- RelaySelector
RelayManager --> QUICPeer

RelayPeer --> RelayDB
RelayPeer *-- RelaySession

RelaySelector *-- RelayCandidate

PeerMetadataDB ..> PeerMetadata : stores
PeerMetadata *-- NetworkInfo

RelayCandidate --> PeerMetadata

' Message types (enums)
enum MessageType {
    MessageTypePing
    MessageTypePong
    MessageTypeMetadataRequest
    MessageTypeMetadataResponse
    MessageTypeRelayRegister
    MessageTypeRelayAccept
    MessageTypeRelayReject
    MessageTypeRelaySessionQuery
    MessageTypeRelaySessionStatus
    MessageTypeRelayDisconnect
}

class RelaySessionQueryData {
    + ClientNodeID: string
    + QueryNodeID: string
}

class RelaySessionStatusData {
    + ClientNodeID: string
    + HasSession: bool
    + SessionID: string
    + SessionActive: bool
    + LastKeepalive: int64
}

QUICPeer ..> MessageType : uses
QUICPeer ..> RelaySessionQueryData : sends
QUICPeer ..> RelaySessionStatusData : receives
RelayPeer ..> RelaySessionStatusData : sends

@enduml
